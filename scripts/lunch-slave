#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Lunch
# Copyright (C) 2009 Société des arts technologiques (SAT)
# http://www.sat.qc.ca
# All rights reserved.
#
# This file is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# Lunch is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Lunch.  If not, see <http://www.gnu.org/licenses/>.
"""
Tools for process management.
"""
__version__ = "0.2.0"
DESCRIPTION = "The lunch slave utility is an interactive process launcher. It is intended to be run by the lunch master process through an encrypted SSH connection. It launches a single process at a time and allows to specify its environment and to log its standard output and error to a file."

import os
import sys
import logging

from twisted.internet import protocol
from twisted.internet import reactor
from twisted.internet import stdio
from twisted.protocols import basic
from twisted.python import procutils

def _is_in_devel():
    d = os.path.split(os.path.dirname(os.path.abspath(__file__)))[1]
    return d == "scripts"

if __name__ == "__main__":
    if _is_in_devel():
        d = os.path.split(os.path.dirname(os.path.abspath(__file__)))[0]
        sys.path.insert(0, d)

from lunch import constants as const

class SlaveError(Exception):
    """
    Raised by the Slave
    """
    pass

def call_callbacks(callbacks, *args, **kwargs):
    """
    Calls each callable in the list of callbacks with the arguments and keyword-arguments provided.
    """
    for c in callbacks:
        c(*args, **kwargs)

class ChildProcess(protocol.ProcessProtocol):
    """
    Process managed by a Lunch Slave.
 
    Its stdout and stderr streams are logged to a file.    
    """
    def __init__(self, slave):
        """
        @param slave: Slave instance.
        """
        self.slave = slave

    def connectionMade(self):
        """
        Called once the process is started.
        """
        self.slave._on_connection_made()

    def outReceived(self, data):
        """
        Called when text is received from the managed process stdout
        Twisted will not splitlines, it gives an arbitrary amount of
        data at a time. 

        Here, we make sure our slave manager only gets one line at a time.
        """
        for line in data.splitlines():
            if line != "":
                self.slave._stdout_file.write(line + "\n")

    def errReceived(self, data):
        """
        Called when text is received from the managed process stderr
        """
        for line in data.splitlines().strip():
            if line != "":
                self.slave._stdout_file.write(line + "\n")

    def processEnded(self, reason):
        """
        Called when the child process has exited.
        status is probably a twisted.internet.error.ProcessTerminated
        "A process has ended with a probable error condition: process ended by signal 1"
        
        This is called when all the file descriptors associated with the child 
        process have been closed and the process has been reaped. This means it 
        is the last callback which will be made onto a ProcessProtocol. 
        The status parameter has the same meaning as it does for processExited.
        """
        exit_code = reason.value.exitCode
        if exit_code is None:
            exit_code = reason.value.signal
        self.slave._on_process_ended(exit_code)
    
    def inConnectionLost(self, data):
        #self.slave.log("stdin pipe has closed." + str(data))
        pass
        
    def outConnectionLost(self, data):
        #self.slave.log("stdout pipe has closed." + str(data))
        pass
        
    def errConnectionLost(self, data):
        #self.slave.log("stderr pipe has closed." + str(data))
        pass

    def processExited(self, reason):
        """
        This is called when the child process has been reaped, and receives 
        information about the process' exit status. The status is passed in the form 
        of a Failure instance, created with a .value that either holds a ProcessDone 
        object if the process terminated normally (it died of natural causes instead 
        of receiving a signal, and if the exit code was 0), or a ProcessTerminated 
        object (with an .exitCode attribute) if something went wrong.
        """
        self.slave.log("process has exited " + str(reason))
    
class Slave(object):
    """
    Slave that manages a process. 
    
    The command, identifier and env can be set after object creation.
    """
    def __init__(self, command=None, identifier=None, env=None):
        """
        @param command: Shell string. The first item is the name of the name of the executable.
        @param identifier: Any string. Used as a file name, so avoid spaces and exotic characters.
        """
        self.state = const.STATE_IDLE
        self.io_protocol = None # this attribute is set directly to the SlaveIO instance once created.
        self.command = command # string
        self.identifier = identifier # title
        self.env = {} # environment variables for the child process
        if env is not None:
            self.env.update(env)
        self.log_dir = os.path.join(os.getcwd(), "lunch")
        self._stdout_file = None
        self.pid = None
        self.log_callbacks = []
        if self.identifier is None:
            self.identifier = "default"
        self.log_level = logging.DEBUG
    
    def start(self):
        """
        Starts the child process
        """
        if self.state in [const.STATE_RUNNING, const.STATE_STARTING]:
            msg = "Child is already %s. Cannot start it." % (self.state)
            self.io_protocol.send_error(msg)
            return
        elif self.state == const.STATE_STOPPING:
            msg = "Child is %s. Please try again to start it when it will be stopped." % (self.state)
            self.io_protocol.send_error(msg)
            # TODO: The Master should try again later.
            return
        if self.command is None:
            msg = "You must provide a command to be run."
            self.io_protocol.send_error(msg)
            return
        else:
            try:
                self.command[0] = procutils.which(self.command[0])[0]
            except IndexError:
                msg = "Could not find path of executable %s." % (self.command[0])
                self.io_protocol.send_error(msg)
                return
        if not os.path.exists(self.log_dir):
            try:
                os.makedirs(self.log_dir)
            except OSError, e:
                self.io_protocol.send_error("Could not create log directory %s." % (self.log_dir))
                return
            else:
                self.log("Created directory %s" % (self.log_dir))
        stdout_file_name = os.path.join(self.log_dir, "%s.log" % (self.identifier))
        try:
            # TODO: erase previous stdout_file if desired.
            self._stdout_file = file(stdout_file_name, "a") # open in append mode
        except OSError, e:
            self.io_protocol.send_error("Could not open log file %s in write mode." % (stdout_file_name))
            return
        else:
            self.log("Writing to %s" % (stdout_file_name))
        self.log("Slave %s will run command %s" % (self.identifier, str(self.command)))
        self._child_process = ChildProcess(self)
        proc_path = self.command[0]
        args = self.command
        environ = {}
        for key in ['HOME', 'DISPLAY', 'PATH']: # passing a few env vars
            if os.environ.has_key(key):
                environ[key] = os.environ[key]
        for key, val in self.env.iteritems():
            environ[key] = val
        self.set_state(const.STATE_STARTING)
        #self.log("Identifier: %s" % (self.identifier))
        #self.log("Environment variables: %s" % (str(environ)))
        self._process_transport = reactor.spawnProcess(self._child_process, proc_path, args, environ, usePTY=True)
        self.log("Spawned process %s." % (self.identifier))
    
    def _on_connection_made(self):
        if not const.STATE_STARTING:
            self.log("Connection made even if we were not starting the child process.", logging.ERROR)
        self.set_state(const.STATE_RUNNING)
    
    def stop(self):
        """
        Stops the child process
        """
        if self.state in [const.STATE_RUNNING, const.STATE_STARTING]:
            self.set_state(const.STATE_STOPPING)
            self.log('Will stop process.')
            try:
                self._process_transport.signalProcess(15) # signal.SIGTERM
            except OSError, e:
                self.log("Error sending SIGKILL. %s" % (e))
            #TODO: later, make sure it is correctly killed.
            self._process_transport.loseConnection()
        elif self.state == const.STATE_STOPPING:
            self.log('Trying to kill again the child process. Using kill -9.')
            try:
                self._process_transport.signalProcess(9) # signal.SIGKILL
            except OSError, e:
                self.log("Error sending SIGKILL. %s" % (e))
        else: # STOPPED
            msg = "Process is already stopped."
            self.set_state(const.STATE_STOPPED)
            self.io_protocol.send_error(msg)
            return

    def log(self, msg, level=logging.DEBUG):
        """
        Logs to Master.
        (through stdout)
        """
        if level >= self.log_level:
            call_callbacks(self.log_callbacks, msg, level)

    def _on_process_ended(self, exit_code):
        if self.state == const.STATE_STOPPING:
            self.log('Child process exited as expected.')
        elif self.state == const.STATE_STARTING:
            self.log('Child process exited while trying to start it.')
        elif self.state == const.STATE_RUNNING:
            if str(reason).find('exit code 0') != -1:
                self.log('Child process exited.')
            else:
                self.log('Child process exited with error.')
        self.log("Child exitted with %s" % (exit_code), logging.INFO)
        self.set_state(const.STATE_STOPPED)
        self.log("Closing slave's process stdout file.")
        self._stdout_file.close()
        
    def set_state(self, new_state):
        """
        Handles state changes.
        """
        if self.state != new_state:
            self.state = new_state
            self.io_protocol.send_state(self.state)
        
class SlaveIO(basic.LineReceiver):
    """
    Interactive commands for the slave using its standard input and output.
    """
    delimiter = '\n' # unix terminal style newlines. remove this line
                     # for use with Telnet
    log_keys = {
        logging.DEBUG: "DEBUG",
        logging.INFO: "INFO",
        logging.WARNING: "WARNING",
        logging.CRITICAL: "CRITICAL",
        logging.ERROR: "ERROR",
        }
    
    def __init__(self, slave):
        self.slave = slave
        slave.io_protocol = self
    
    def connectionMade(self):
        self.send_message("Welcome to the Lunch slave console. Type 'help' for help.")
        if self._on_log not in self.slave.log_callbacks:
            self.slave.log_callbacks.append(self._on_log)

    def _on_log(self, msg, level=logging.INFO):
        self.send_log(msg, level)

    def lineReceived(self, line):
        """
        Commands are in the form "command arg"
        Answers are in the form "key: message"
        """
        if line == "": 
            return
        # Parse the command
        try:
            key = line.split(" ")[0].lower()
            mess = line[len(key) + 1:]
        except IndexError, e:
            self.send_log("Index error parsing command-line." % (e), logging.ERROR)
        
        # Dispatch the command to the appropriate method.  Note that all you
        # need to do to implement a new command is add another do_* method.
        try:
            method = getattr(self, 'do_' + key)
        except AttributeError, e:
            self.sendLine('%s no such command.' % (const.MESSAGE_ERROR))
        else:
            method(mess)

    def do_help(self, line):
        """
        help [command]: List commands, or show help on the given command.
        """
        args = line.split()
        if len(args) == 1:
            command = args[0]
            self.sendLine(getattr(self, 'do_' + command).__doc__)
        else:
            commands = [cmd[3:] for cmd in dir(self) if cmd.startswith('do_')]
            self.sendLine("%s Valid commands: %s" %  (const.MESSAGE_MSG, " ".join(commands)))

    def send_state(self, state):
        self.sendLine("%s %s" % (const.MESSAGE_STATE, state))
    
    def do_quit(self, line):
        """quit: Quit this session"""
        if self.slave.state == const.STATE_RUNNING:
            self.send_log("Slave is still running. Need to stop it.") # XXX
            self.slave.stop()
        self.send_quit()
        self.transport.loseConnection()

    def send_quit(self):
        """
        Confirms that we will stop this slave.
        """
        self.sendLine('%s Goodbye.' % (const.ANSWER_QUIT))
        
    #def do_set(self, name, value=None):
    #    """set: Sets a configuration value. Usage: set <name> <value>"""
    #    if hasattr(self.slave, name):
    #        _type = type(getattr(self.slave, name))
    #        try:
    #            setattr(self.slave, _type(value))
    #        except ValueError, e:
    #            self.send_error("Bad type for %s. \"%s\" is not a valid %s." % (name, value, _type.__name__))
    
    def do_command(self, line):
        """command: sets the shell command to be run."""
        li = line.split() # TODO: do not split it, use bash !
        if len(li) == 0:
            self.send_error("Cannot use an empty command.")
            return
        self.send_message("Using %s as a command to run." % (li))
        self.slave.command = li
        self.send_ok()

    def do_env(self, line):
        """Sets the env vars for the process. Must be in a string of key=value separated by spaces."""
        args = line.split()
        for key_val in args:
            try:
                k, v = key_val.split("=")
            except ValueError:
                self.send_error("%s %s" % ("Wrong env key-value pair:", key_val))
            else:
                self.send_log("Setting env var $%s=%s." % (k, v), logging.DEBUG)
                self.slave.env[k] = v

    def send_ok(self):
        self.sendLine("OK")

    def do_run(self, line):
        """run: Starts the process."""
        self.slave.start()
    
    def do_stop(self, line):
        """stop: Stops the process."""
        self.slave.stop()

    def do_ping(self, line):
        """ping: Answers with PONG"""
        #TODO : check if slave process is running
        self.send_pong()

    def send_error(self, msg):
        self.sendLine("%s %s" % ("ERROR", msg))
    
    def send_message(self, msg):
        self.sendLine("%s %s" % ("MSG", msg))

    def send_pong(self):
        self.sendLine("pong")

    def send_log(self, msg, level=logging.DEBUG):
        key = self.log_keys[level]
        self.sendLine("%s %s %s" % ("log", key, msg))

    def do_status(self, line):
        """status: prints the state of the slave."""
        self.sendLine("%s %s" % (const.ANSWER_STATUS, self.slave.state))

    def connectionLost(self, reason):
        # stop the reactor, only because this is meant to be run in Stdio.
        try:
            self.slave.log_callbacks.remove(self._on_log) # XXX !
        except ValueError, e:
            pass
        if self.slave.state != const.STATE_STOPPED:
            try:
                self.slave.stop()
            except SlaveError, e:
                self.send_error("%s" % (e))
        if reactor.running != 0:
            reactor.stop()

def run_slave():
    """
    Runs the slave application.
    """
    from optparse import OptionParser
    parser = OptionParser(usage="%prog [options]", version="%prog " + __version__, description=DESCRIPTION)
    parser.add_option("-i", "--id", type="string", help="Identifier of this lunch slave.")
    (options, args) = parser.parse_args()
    kwargs = {}
    if options.id:
        kwargs["identifier"] = options.id
    slave = Slave(**kwargs)
    slave_io = SlaveIO(slave)
    stdio.StandardIO(slave_io)
    try:
        reactor.run()
    except KeyboardInterrupt:
        reactor.stop()

if __name__ == "__main__":
    run_slave()
