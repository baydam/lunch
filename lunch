#!/usr/bin/env python
# -*- coding: utf-8 -*-
# 
# Lunch
# Copyright (C) 2008 Société des arts technologiques (SAT)
# http://www.sat.qc.ca
# All rights reserved.
#
# This file is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# Lunch is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Lunch. If not, see <http://www.gnu.org/licenses/>.

"""
Simply runs a process on the local machine.
Allows specifying environment variables.

Can be run as a server controlling remote computers with ssh security:: 
 lunch

Can also be run as a single process launcher in a rxvt terminal.
 lunch -c glxgears -e DISPLAY :0.0
 
 ssh -X brrr rxvt -e "lunch -c \"glxgears\" -e DISPLAY :0.0"
"""
# TODO: use log instead of print
# TODO: create config dir/file if not found
# TODO: change config file to .lunch
# TODO: allow xterm terminal
# TODO: get rid of the ~/.lunch directory and simply use it as a file.
import os
import sys
from optparse import OptionParser
import subprocess
import multiprocessing
import logging
import time

__version__ = "0.1 alpha"
EPILOG = """Released under the terms of the GNU General Public License 2.
Copyright 2009 Society for Arts and Technology."""
DESCRIPTION = """Lunch is a distributed process launcher for GNU/Linux. 
It uses the following software packages : rxvt-unicode, ssh (configured using ssh-keygen, ssh-agent and ssh-keyinstall). 
Lunch itself must be installed on every host. """
CONFIG_FILE = os.path.expanduser("~/.lunch/config")
VERBOSE = False
HOLD_TERMINAL = False
RESTART_WHEN_DEAD = True
ENABLE_MINIMUM_PROCESS_TIME = True
MINIMUM_PROCESS_TIME = 1.0 # minimum time a process must last to be considered successful
LOGGING_ENABLED = False
_commands = []

#class ParentKilledError(Exception):
#    """Raised when parent is killed by ctrl-c"""
#    pass

class ChildKilledError(Exception):
    """Raised when child is killed"""
    pass

class ExecutionFailedError(Exception):
    """Raised when a command quickly returns an error, or when shell raises an OSError"""
    pass

def run_command(command_str, variables_dict={}, die_on_ctrl_c=True):
    """
    Creates and launches a process. 

    Uses subprocess to launch a process. Blocking.
    When called, might throw a OSError or ValueError.
    Throws a ChildKilledError if ctrl-C is pressed.
    """
    global VERBOSE
    retcode = None
    environment = {}
    environment.update(os.environ)
    environment.update(variables_dict)
    try:
        if VERBOSE:
            print("--------")
        print("COMMAND: %s" % (command_str))
        p = subprocess.Popen(command_str, shell=True, env=environment)
        print("PID: %s" % (p.pid))
        if VERBOSE:
            print("ENV: %s" % (str(variables_dict)))
            print("--------")
        retcode = p.wait() # blocking
        if retcode < 0:
            err = "Child was terminated by signal %d\n" % (retcode)
            sys.stderr.write(err)
        else:
            err = "Child returned %s\n" % (retcode)
            sys.stderr.write(err)
    except OSError, e:
        err = "Execution of child failed: %s\n" % (e.message)
        sys.stderr.write(err)
        retcode = 1
    except KeyboardInterrupt, e:
        if die_on_ctrl_c:
            print("Ctrl-C has been pressed in a slave terminal. Dying.")
            sys.exit(1)
        else:
            raise ChildKilledError("Ctrl-C has been pressed in the master's terminal and caught by a worker.")
    except ValueError, e:
        err = "Wrong arguments to subprocess.Popen: %s\n" % (e.message)
        sys.stderr.write(err)
        raise
    #else:
        #print("Success\n") # retrcode is p.wait() return val
    return retcode

def run_slave(command_str, vars={}):
    """
    Runs a slave. (a command (on remote host) to start a single process)
    
    Alias to run_command, but called from 
    either the master on the local host of a slave "lunch" software on a remote host.
    """
    return run_command(command_str, vars, True) # Dies on ctrl-C

class Command(object):
    """
    One command to run on a remote or local host.

    Class with no method.
    Default priority is 100
    """
    def __init__(self, command="", env={}, host=None, user=None, priority=100, title="rxvt_slave", sleep=0.1):
        self.command = command
        self.env = env
        self.host = host
        self.user = user
        self.title = title
        self.priority = priority
        self.sleep = sleep

def add_command(command="", env={}, host=None, user=None, priority=100, title="rxvt_slave", sleep=0.1):
    """
    This is the only function that users use from within the configuration file.
    It adds a Command instance to the list of commands to run. 
    
    Default priority is 100. The lowest the earliest.
    """
    global _commands
    global VERBOSE
    if VERBOSE:
        print("adding %s %s %s %s %s %s %s" % (command, env, host, user, priority, title, sleep)) # EDIT ME
    _commands.append(Command(command, env, host, user, priority, title, sleep)) # EDIT ME

def sorting_callback(x, y):
    """
    Sorts Command objects using their priority attribute.
    
    To define a compare function for sort(), you must follow certain pattern.
    1. Compare function must take TWO param: x and y,
    2. It should return positive number if x > y, return negative number if x< y and return 0 if they are equal for Ascending sort.
    """
    if x.priority > y.priority:
        return 1
    elif x.priority < y.priority:
        return -1
    else:
        return 0

class FileNotFoundError(Exception):
    """
    Thrown when a file could not be found.
    """
    pass

def run_master(config_file):
    """
    Runs the master that calls commands using ssh or so.

    This happens only on the master computer.
     * reads config file
     * uses multiprocessing to create many workers. (calling start_worker)
       Those worker launch the "lunch" program in a rxvt terminal.
       (maybe through ssh, if on a remote host)
     * If ctrl-C is pressed from any worker, dies.
    """
    global _commands
    if os.path.exists(config_file):
        try:
            execfile(config_file) # config is plain python using the globals defined here. (the add_process function)
        except Exception, e:
            print("Error in user configuration file.")
            raise
    else:
        # create the directory ?
        raise FileNotFoundError("Could not find the %s file." % (config_file))
    # init multiprocessing
    if LOGGING_ENABLED:
        multiprocessing.log_to_stderr(level=logging.INFO) # level=logging.DEBUG)
        log = multiprocessing.get_logger()
        # log.warning("test debug")
    workers = []
    queue = multiprocessing.Queue()
    _commands.sort(sorting_callback)
    try:
        for command in _commands:
            user = command.user
            host = command.host
            title = command.title
            cmd = command.command
            env = "" # make str from dict
            hold = ""
            if HOLD_TERMINAL:
                hold = "-hold"
            if len(command.env) > 0:
                for k, v in command.env.items():
                    env += " -e %s %s " % (k, v)
            command_str = 'rxvt -T "%s" %s -e lunch %s -s -c "%s"' % (title, hold, env, cmd) 
            if command.host is not None:
                if command.user is None:
                    print("If you provide a host, you must provide a user." + str(command.__dict__))
                    sys.exit(1)
                command_str = 'ssh -X %s@%s rxvt -T "%s" %s -e lunch %s -s -c \\"%s\\"' % (user, host, title, hold, env, cmd) # prepend ssh command
                # TODO: how to escape commands properly ? 
                # TODO: Maybe better to use sys.argv for every args after --command
            # create server
            process = multiprocessing.Process(group=None, target=start_worker, name=command_str, args=(command_str, command.env, queue))
            workers.append(process)
            process.start()
            time.sleep(command.sleep)
        # waiting for a message from any child.
        message = queue.get()
        raise ChildKilledError("A worker received ctrl-C.")
    except ChildKilledError:
        print("Ctrl-C was pressed in master.")
        for worker in workers:
            print("Terminating worker")
            worker.terminate()
            #os.kill(worker.pid(), signal.SIGINT)
    except KeyboardInterrupt:
        print("Ctrl-C was pressed in master.")
        for worker in workers:
            print("Terminating worker")
            worker.terminate()
            #os.kill(worker.pid(), signal.SIGINT)

def start_worker(command, vars={}, queue=None):
    """ 
    A multiprocessing worker will run as its own process 
    """
    print("Starting command: " + str(command))
    while True: # runs forever.
        try:
            started = time.time()
            ret = run_command(command, vars, False) # throw an error on ctrl-C (this should be blocking)
            if ret == 1:
                print("Child process returned an error. Will not try to run it again.")
                break
            if ENABLE_MINIMUM_PROCESS_TIME:
                if time.time() < (started + MINIMUM_PROCESS_TIME):
                    print("Process did not last long enough. Will not be run again.")
                    break
        except ChildKilledError:
            # break
            if queue is not None:
                queue.put(["Ctrl-C !"])
            # raise
        else:
            print("Return value is %s" % (ret))
            if not RESTART_WHEN_DEAD:
                break
            else:
                print("running it again")
                time.sleep(0.1)


if __name__ == "__main__":
    parser = OptionParser(usage="%prog [options]", version="%prog " + __version__, epilog=EPILOG, description=DESCRIPTION)
    #parser.add_option("-m", "--master", action="store_true", help="Run as master lunch server.")
    parser.add_option("-s", "--slave", action="store_true", help="Run in slave mode to launch a single process. The --command option is mandatory when in slave mode.")
    parser.add_option("-d", "--disable-minimum-process-time", action="store_true", help="Restart process even if it did not long last.")
    parser.add_option("-H", "--hold", action="store_true", help="Hold the rxvt terminal window once it quit.")
    parser.add_option("-t", "--minimum-time", type="float", help="Sets the minimum time that a process must last to be considered crashed. Only in slave mode for now. Default is %f seconds." % (MINIMUM_PROCESS_TIME))
    parser.add_option("-R", "--no-resurrect", action="store_true", help="Do not resurrect processes when they die.")
    parser.add_option("-v", "--verbose", action="store_true", help="Run in the verbose mode.")
    parser.add_option("-c", "--command", type="string", help="Command to execute. This options is mandatory when in slave mode.")
    parser.add_option("-e", "--environment", action="append", nargs=2, help="Sets an environment variable with key/value pair.")
    parser.add_option("-f", "--config-file", type="string", default=CONFIG_FILE, help="If run as master, specifies the python config file.")
    (options, args) = parser.parse_args()
    if options.minimum_time:
        MINIMUM_PROCESS_TIME = options.minimum_time
    if options.hold:
        HOLD_TERMINAL = True
    if options.disable_minimum_process_time:
        MINIMUM_PROCESS_TIME = False
    if options.verbose:
        VERBOSE = True
    if options.no_resurrect:
        RESTART_WHEN_DEAD = False
    #if not options.master or 
    if options.slave: # run as SLAVE
        #if len(args) == 0:
        if not options.command:
            print("lunch --slave: You must provide a command to execute. Try -h to get help.")
            parser.print_usage()
            sys.exit(1)
        else:
            print("Running Lunch as a slave to launch a single process.")
            # command = " ".join(args)
            command = options.command
            variables_dict = {} # dict of environment variables
            if options.environment:
                variables_dict = options.environment
            print("Additional environment variables: %s" % (str(variables_dict)))
            ret = run_slave(command, variables_dict)
    else: # run as MASTER
        #if options.command or 
        if options.environment:
            print("Environment variables can only be set when run in slave mode.")
            parser.print_usage()
            sys.exit(1)
        else:
            # run_master(CONFIG_FILE)
            try:
                run_master(options.config_file)
            except FileNotFoundError, e:
                print("Error starting lunch as master.")
                print(e.message)
                print("A configuration file is missing. Try the --help flag.")
                sys.exit(1)
        
